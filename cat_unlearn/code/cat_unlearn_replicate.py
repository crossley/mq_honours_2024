from imports import *
from util_func import *

"""
- This code runs a replication -- sort of -- of the
  unlearning task from Crossley, Ashby, and Maddox (2013).

- The conditions are either fully random intervention or
  75/25 mixed. Subjects are allocated to one condition or
  the other based on their subject number. Even subject
  numbers are assigned to the fully random intervention and
  odd subject numbers are assigned to the 75/25 mixed
  condition.

- The logic of the random / mixed / veridical feedback is
  all implemented in the `state_feedback` state.

- The main differences between this code and the original is
  that here we use gratings instead of lines and we use
  2-label categories instead of 4-label categories. I have
  also implemented a novel -- as far as I know -- category
  sampling method. In particular, I sample uniformly within
  the contours of equal likelihood taken from 3 sd from a
  traditional II bivariate Gaussian distribution.

- To modify the categories and the number of trials -- which
  is inhereted from the number of rows in the stimuli data
  frame generated by the function `make_stim_cats` found in
  the `util_func` module -- you can modify the `make_stim_cats`
  function.

- The data is saved in a csv file in the `data` directory.
  The top of the code contains a variable `subject` which
  you should adjust with every new participant. The top of
  the code also contains a check to see if the file already
  exists. This can be annoying during development and
  debugging so I often comment it out -- which leads to
  overwriting the any existing file with the same name --
  but please remember to leave it active for real data
  collection.

- There is not currently a way to pause the experiment and
  there are no blocks or breaks. We may wish to add these
  but I'm not sure.

- The code also does not currently ever display explicit
  instructions which will be the main manipulation we will
  need to add after we verify / replicate the original.

- Task instructions must be given verbally in the lab. They
  are not automated in this code.

- Consent must also currently be given and recorded manually
  in the lab, but we may pivot to automation down the road.
"""

# set subject number
subject = 1
dir_data = "../data"
f_name = f"sub_{subject}_data.csv"
full_path = os.path.join(dir_data, f_name)

# Uncomment to check if file already exists
if os.path.exists(full_path):
    print(f"File {f_name} already exists. Aborting.")
    sys.exit()

ds = make_stim_cats()

# # plot the stimuli coloured by label
# fig, ax = plt.subplots(1, 2, squeeze=False, figsize=(12, 6))
# sns.scatterplot(data=ds, x="x", y="y", hue="cat", alpha=0.5, ax=ax[0, 0])
# sns.scatterplot(data=ds, x="xt", y="yt", hue="cat", alpha=0.5, ax=ax[0, 1])
# ax[0, 0].plot([0, 100], [0, 100], 'k--')
# ax[0, 1].plot([0, 5], [0, np.pi / 2], 'k--')
# plt.show()

# plot_stim_space_examples(ds)

# Initialize Pygame
pygame.init()

# useful constants but need to change / verify on each computer
pixels_per_inch = 227 / 2
px_per_cm = pixels_per_inch / 2.54

# grating size
size_cm = 5
size_px = int(size_cm * px_per_cm)

# set small window potentially useful for debugging
# screen_width, screen_height = 800, 600
# center_x = screen_width // 2
# center_y = screen_height // 2
# screen = pygame.display.set_mode((screen_width, screen_height))

# set full screen
info = pygame.display.Info()
screen_width, screen_height = info.current_w, info.current_h
center_x = screen_width // 2
center_y = screen_height // 2
screen = pygame.display.set_mode((screen_width, screen_height), pygame.FULLSCREEN)

# Hide the mouse cursor
pygame.mouse.set_visible(False)

# Set up fonts
font = pygame.font.Font(None, 36)

# Define colors
black = (0, 0, 0)
white = (255, 255, 255)
grey = (126, 126, 126)
green = (0, 255, 0)
red = (255, 0, 0)

# create clocks to keep time
clock_state = pygame.time.Clock()
clock_exp = pygame.time.Clock()

time_state = 0.0
time_exp = 0.0

# set the current state to the initial state
state_current = "state_init"

# behavioural measurements
resp = -1
rt = -1

# trial counter
trial = -1
n_trial = ds.shape[0]

# record keeping
trial_data = {
    'subject': [],
    'trial': [],
    'cat': [],
    'x': [],
    'y': [],
    'xt': [],
    'yt': [],
    'resp': [],
    'rt': []
}

running = True
while running:

    time_exp += clock_exp.tick()

    for event in pygame.event.get():
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                keep_running = False
                pygame.quit()
            else:
                resp = event.key

    if state_current == "state_init":
        time_state += clock_state.tick()
        text = font.render("Please press the space bar to begin", True,
                           (255, 255, 255))
        text_rect = text.get_rect(center=(screen_width / 2, screen_height / 2))
        screen.fill(grey)
        screen.blit(text, text_rect)
        if resp == pygame.K_SPACE:
            time_state = 0
            resp = -1
            state_current = "state_iti"

    if state_current == "state_finished":
        time_state += clock_state.tick()
        text = font.render("You finished! Thank you for being awesome!", True,
                           (255, 255, 255))
        text_rect = text.get_rect(center=(screen_width / 2, screen_height / 2))
        screen.fill(grey)
        screen.blit(text, text_rect)

    if state_current == "state_iti":
        time_state += clock_state.tick()
        screen.fill(grey)
        pygame.draw.line(screen, white, (center_x, center_y - 10),
                         (center_x, center_y + 10), 4)
        pygame.draw.line(screen, white, (center_x - 10, center_y),
                         (center_x + 10, center_y), 4)
        if time_state > 1000:
            resp = -1
            rt = -1
            time_state = 0
            trial += 1
            if trial == n_trial:
                state_current = "state_finished"
            else:
                sf = ds['xt'].iloc[trial] * px_per_cm**-1
                ori = ds['yt'].iloc[trial]
                cat = ds['cat'].iloc[trial]
                state_current = "state_stim"

    if state_current == "state_stim":
        time_state += clock_state.tick()
        screen.fill(grey)
        grating_patch = create_grating_patch(size_px, sf, ori)
        grating_surface = grating_to_surface(grating_patch)
        screen.blit(grating_surface,
                    (center_x - size_px / 2, center_y - size_px / 2))
        if (resp == pygame.K_d) or (resp == pygame.K_k):
            rt = time_state
            time_state = 0
            state_current = "state_feedback"

    if state_current == "state_feedback":
        time_state += clock_state.tick()

        # Give veridical feedback in all conditions during
        # acquisition and reacquisition
        if (trial < 300) or (trial >= 600):
            if resp == pygame.K_d:
                resp = "A"
                if cat == "A":
                    fb = "Correct"
                else:
                    fb = "Incorrect"

            elif resp == pygame.K_k:
                resp = "B"
                if cat == "B":
                    fb = "Correct"
                else:
                    fb = "Incorrect"
        else:
            # if subject is an even number --> 100% random
            # intervention
            if subject % 2 == 0:
                # random feedback
                if np.random.rand() < 0.5:
                    fb = "Correct"
                else:
                    fb = "Incorrect"

            # if subject is an odd number --> 7525 mixed
            # intervention
            else:
                # give veridical feedback 25% of the time
                if np.random.rand() < 0.25:
                    if resp == pygame.K_d:
                        resp = "A"
                        if cat == "A":
                            fb = "Correct"
                        else:
                            fb = "Incorrect"

                    elif resp == pygame.K_k:
                        resp = "B"
                        if cat == "B":
                            fb = "Correct"
                        else:
                            fb = "Incorrect"

                # Give 100% random feedback the rest of the time
                else:
                    if np.random.rand() < 0.5:
                        fb = "Correct"
                    else:
                        fb = "Incorrect"

        if fb == "Correct":
            pygame.draw.circle(screen, green, (center_x, center_y),
                               size_px / 2 + 10, 5)

        elif fb == "Incorrect":
            pygame.draw.circle(screen, red, (center_x, center_y),
                               size_px / 2 + 10, 5)

        if time_state > 1000:
            trial_data['subject'].append(subject)
            trial_data['trial'].append(trial)
            trial_data['cat'].append(cat)
            trial_data['x'].append(np.round(ds.x[trial], 2))
            trial_data['y'].append(np.round(ds.y[trial], 2))
            trial_data['xt'].append(np.round(sf, 2))
            trial_data['yt'].append(np.round(ori, 2))
            trial_data['resp'].append(resp)
            trial_data['rt'].append(rt)
            pd.DataFrame(trial_data).to_csv(full_path, index=False)
            time_state = 0
            state_current = "state_iti"

    pygame.display.flip()
